# Список (list) представляет тип данных, который хранит набор или последовательность элементов. Для создания списка
# в квадратных скобках ([]) через запятую перечисляются все его элементы. Во многих языках программирования есть
# аналогичная структура данных, которая называется массив
numbers = [1, 2, 3, 4, 5]
numbers1 = []       # создаю пустой список
numbers2 = list()   # создаю пустой список
numbers3 = list(numbers) # Конструктор list для создания списока может принимать другой список

# Для обращения к элементам списка надо использовать индексы (Индексы начинаются с нуля), которые представляют номер элемента
print(numbers[0])  # 1
print(numbers[2])  # 3
# Для обращения к элементам с конца можно использовать отрицательные индексы, начиная с -1.
# То есть у последнего элемента будет индекс -1, у предпоследнего -2 и так далее:
print(numbers[-3])  # 3

numbers[0] = 125  # изменяем первый элемент списка
print(numbers[0])  # 125
# определим список из шести пятерок:
numbers = [5] * 6  # == [5, 5, 5, 5, 5, 5]
print(numbers)

# если нам необходим последовательный список чисел, то для его создания удобно использовать функцию range
#    range(end):                создается набор чисел от 0 до числа end
#    range(start, end):         создается набор чисел от числа start до числа end
#    range(start, end, step):   создается набор чисел от числа start до числа end с шагом step
numbers = list(range(10))
print(numbers)      # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
numbers = list(range(2, 10))
print(numbers)      # [2, 3, 4, 5, 6, 7, 8, 9]
numbers = list(range(10, 2, -2))
print(numbers)      # [10, 8, 6, 4]

# следующие два определения списка будут аналогичны, но за счет функции range мы сокращаем объем кода
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]
numbers2 = list(range(1, 10))

# Мы можем поместить в один и тот же список одновременно строки, числа, объекты других типов данных:
objects = [1, 2.6, "Hello", True]

#---------------------------------------------------------------------------------------------
# Перебор элементов
# Для перебора элементов можно использовать как цикл for, так и цикл while.
companies = ["Microsoft", "Google", "Oracle", "Apple"]
# Перебор с помощью цикла for:
for item in companies:
    print(item)

# Перебор с помощью цикла while:
i = 0
while i < len(companies):
    print(companies[i])
    i += 1

#---------------------------------------------------------------------------------------------
# Сравнение списков
# Два списка считаются равными, если они содержат один и тот же набор элементов:
numbers = [2, 1, 3, 4, 5, 6, 7, 8, 9]
numbers2 = list(range(1,10))
if numbers == numbers2:
    print("numbers equal to numbers2")
else:
    print("numbers is not equal to numbers2")

#---------------------------------------------------------------------------------------------
# Методы и функции по работе со списками

# Для управления элементами списки имеют целый ряд методов. Некоторые из них:
# append(item): добавляет элемент item в конец списка
# insert(index, item): добавляет элемент item в список по индексу index
# remove(item): удаляет элемент item. Удаляется только первое вхождение элемента. Если элемент не найден, генерирует исключение ValueError
# clear(): удаление всех элементов из списка
# index(item): возвращает индекс элемента item. Если элемент не найден, генерирует исключение ValueError
# pop([index]): удаляет и возвращает элемент по индексу index. Если индекс не передан, то просто удаляет последний элемент.
# count(item): возвращает количество вхождений элемента item в список
# sort([key]): сортирует элементы. По умолчанию сортирует по возрастанию. Но с помощью параметра key мы можем передать функцию сортировки.
# reverse(): расставляет все элементы в списке в обратном порядке

# Кроме того, Python предоставляет ряд встроенных функций для работы со списками:
# len(list): возвращает длину списка
# sorted(list, [key]): возвращает отсортированный список
# min(list): возвращает наименьший элемент списка
# max(list): возвращает наибольший элемент списка

# ---------- Добавление и удаление элементов
users = ["Tom", "Bob"]

# добавляем в конец списка
users.append("Alice")           # ["Tom", "Bob", "Alice"]
# добавляем на вторую позицию
users.insert(1, "Bill")         # ["Tom", "Bill", "Bob", "Alice"]

# получаем индекс элемента
i = users.index("Tom")
# удаляем по этому индексу
removed_item = users.pop(i)     # ["Bill", "Bob", "Alice"]

last_user = users[-1]
# удаляем последний элемент
users.remove(last_user)         # ["Bill", "Bob"]
print(users)

# удаляем все элементы
users.clear()

# ---------- Проверка наличия элемента
companies = ["Microsoft", "Google", "Oracle", "Apple"]
item = "Oracle"                 # элемент для удаления
if item in companies:           # возвращает True, если элемент item имеется в списке companies
    companies.remove(item)

print(companies)

# Подсчет вхождений
# Если необходимо узнать, сколько раз в списке присутствует тот или иной элемент
users = ["Tom", "Bob", "Alice", "Tom", "Bill", "Tom"]

users_count = users.count("Tom")
print(users_count)  # 3

# ---------- Сортировка
users = ["Tom", "Bob", "Alice", "Sam", "Bill"]

users.sort()
print(users)  # ["Alice", "Bill", "Bob", "Sam", "Tom"]

# отсортировать данные в обратном порядке - reverse()
users = ["Tom", "Bob", "Alice", "Sam", "Bill"]

users.sort()
users.reverse()
print(users)  # ["Tom", "Sam", "Bob", "Bill", "Alice"]
# цифровой символ считается "меньше", чем алфавитный заглавный символ,
# а заглавный символ считается меньше, чем строчный

# Tipps - как для нас строка "bob" должна стоять до строки "Tom". И чтобы изменить стандартное поведение сортировки,
# мы можем передать в метод sort() в качестве параметра функцию:
users = ["Tom", "bob", "alice", "Sam", "Bill"]

users.sort(key=str.lower)
print(users)  # ["alice", "Bill", "bob", "Sam", "Tom"]

# Кроме метода sort мы можем использовать встроенную функцию sorted, которая имеет две формы:
#    sorted(list):          сортирует список list
#    sorted(list, key):     сортирует список list, применяя к элементам функцию key
users = ["Tom", "bob", "alice", "Sam", "Bill"]

sorted_users = sorted(users, key=str.lower)     #эта функция не изменяет сортируемый список, а все отсортированные элементы она помещает в новый список, который возвращается в качестве результата
print(sorted_users)  # ["alice", "Bill", "bob", "Sam", "Tom"]

# ---------- Минимальное и максимальное значения
numbers = [9, 21, 12, 1, 3, 15, 18]
print(min(numbers))     # 1
print(max(numbers))     # 21

# ---------- Копирование списков
# списки представляют изменяемый (mutable) тип, поэтому если обе переменных будут указывать на один и тот же список,
# то изменение одной переменной, затронет и другую переменную:
users1 = ["Tom", "Bob", "Alice"]
users2 = users1
users2.append("Sam")
# users1 и users2 указывают на один и тот же список
print(users1)   # ["Tom", "Bob", "Alice", "Sam"]
print(users2)   # ["Tom", "Bob", "Alice", "Sam"]

# чтобы происходило копирование элементов, но при этом переменные указывали на разные списки, необходимо выполнить
# глубокое копирование (deep copy). Для этого можно использовать метод deepcopy(), который определен во встроенном модуле copy:
import copy

users1 = ["Tom", "Bob", "Alice"]
users2 = copy.deepcopy(users1)
users2.append("Sam")
# пееменные users1 и users2 указывают на разные списки
print(users1)  # ["Tom", "Bob", "Alice"]
print(users2)  # ["Tom", "Bob", "Alice", "Sam"]

# ---------- Копирование части списка
# Если необходимо скопировать не весь список, а только его какую-то определенную часть, то мы можем применять
# специальный синтаксис. который может принимать следующие формы:
#   list[:end]:             через параметр end передается индекс элемента, до которого нужно копировать список
#   list[start:end]:        параметр start указывает на индекс элемента, начиная с которого надо скопировать элементы
#   list[start:end:step]:   параметр step указывает на шаг, через который будут копироваться элементы из списка. По умолчанию этот параметр равен 1.
users = ["Tom", "Bob", "Alice", "Sam", "Tim", "Bill"]

slice_users1 = users[:3]  # с 0 по 3
print(slice_users1)  # ["Tom", "Bob", "Alice"]

slice_users2 = users[1:3]  # с 1 по 3
print(slice_users2)  # ["Bob", "Alice"]

slice_users3 = users[1:6:2]  # с 1 по 6 с шагом 2
print(slice_users3)  # ["Bob", "Sam", "Bill"]

# ---------- Соединение списков
users1 = ["Tom", "Bob", "Alice"]
users2 = ["Tom", "Sam", "Tim", "Bill"]
users3 = users1 + users2
print(users3)   # ["Tom", "Bob", "Alice", "Tom", "Sam", "Tim", "Bill"]

# ---------- Списки списков
# Списки кроме стандартных данных типа строк, чисел, также могут содержать другие списки.
# Подобные списки можно ассоциировать с таблицами, где вложенные списки выполняют роль строк
users = [
    ["Tom", 29],
    ["Alice", 33],
    ["Bob", 27]
]

print(users[0])  # ["Tom", 29]
print(users[0][0])  # Tom
print(users[0][1])  # 29

# Добавление, удаление и исменение общего списка, а также вложенных списков аналогично тому, как это делается с обычными (одномерными) списками:
users = [
    ["Tom", 29],
    ["Alice", 33],
    ["Bob", 27]
]

# создание вложенного списка
user = list()
user.append("Bill")
user.append(41)
# добавление вложенного списка
users.append(user)

print(users[-1])  # ["Bill", 41]

# добавление во вложенный список
users[-1].append("+79876543210")

print(users[-1])  # ["Bill", 41, "+79876543210"]

# удаление последнего элемента из вложенного списка
users[-1].pop()
print(users[-1])  # ["Bill", 41]

# удаление всего последнего вложенного списка
users.pop(-1)

# изменение первого элемента
users[0] = ["Sam", 18]
print(users)  # [ ["Sam", 18], ["Alice", 33], ["Bob", 27]]

# ---------- Перебор вложенных списков:
users = [
    ["Tom", 29],
    ["Alice", 33],
    ["Bob", 27]
]

for user in users:
    for item in user:
        print(item, end=" | ")      # Tom | 29 | Alice | 33 | Bob | 27 | 

